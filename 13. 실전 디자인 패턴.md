# 정리

## 객체지향 기초
* 추상화
* 캡슐화
* 다형성
* 상속

## 객체지향 원칙
* 바뀌는 부분은 캡슐화 한다.
* 상속보다는 구성을 활용한다.
* 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
* 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.
* 클래스는 확장에는 열려있지만 변경에는 닫혀 있어야 한다.(OCP)
* 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
* 진짜 절친에게만 이야기 한다.
* 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.
* 어떤 클래스가 바뀌는 이유는 하나뿐이어야만 한다.

## 디자인 패턴 사용하기
* 억지로 적용하지 말자.
* 디자인 패턴은 돌에 새겨진 글씨가 아니다. 필요에 따라 적절히 변형해서 사용하자.
* 주어진 조건을 만족하는 가장 간단한 해결책을 사용하자. 디자인 패턴을 무조건 써야하는 건 아니다.
* 디자인 패턴 카탈로그를 읽어보고 패턴을 숙지하자. 패턴 사이의 관계도 확실히 이해해야 한다.
* 패턴을 (범주에 따라서) 분류해 그룹을 만들 수 있다. 그룹으로 나누는 것이 패턴 이해에 도움이 된다면 적극적으로 나눠보자.
* 우리가 접한 패턴은 대부분 기존 패턴을 응용한 것이다.
* 패턴의 큰 장점은 공통의 언어로 이야기 할 수 있다는 것이다.

# 디자인 패턴 정의
    패턴(Pattern)은 특정 컨텍스트 내에서 주어진 문제의 해결책이다.

* 컨텍스트(context)란 패턴이 적용되는 상황으로 반복적으로 일어날 수 있는 상황이어야만 한다.
* 문제(problem)란 컨텍스트 내에서 이뤄야 하는 목표로 여기에는 컨텍스트 내의 제약조건도 포함된다.
* 해결책(solution)이란 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻한다.

# 디자인 패턴 분류하기
* 생성 패턴(Creational Pattern)은 객체 인스턴스를 생성하는 패턴으로, 클라이언트와 그 클라이언트가 생성해야하는 객체 인스턴스 사이의 연결을 끊어주는 패턴이다.
* 행동 패턴(Behavioral Pattern)은 클래스와 객체들이 상호작용 하는 방법과 역할을 분담하는 방법을 다루는 패턴이다.
* 구조 패턴(Structural Pattern)은 클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴이다.
* 클래스 패턴(Class Pattern)은 클래스 사이의 관계가 상속으로 어떻게 정의되는지를 다룬다. 클래스 사이의 관계는 대부분 컴파일 할 때 결정된다.
* 객체(Object Pattern)은 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성으로 정의된다. 일반적으로 실행 중에 관계가 결정되므로 보다 동적이고 유연하다.

## 생성
    싱글턴, 추상 팩토리, 팩토레 메소드, 빌더, 프로토타입
    
## 구조
    데코레이터, 컴포지트, 어댑터, 프록시, 퍼사드, 플라이웨이트, 브리지
    
## 행동
    템플릿 메소드, 싱글턴, 옵저버, 반복자, 상태, 전략, 비지터, 중재자, 메멘토, 인터프리터, 역할변경
    
## 클래스
    템플릿 메소드, 팩토리 메소드, 어댑터, 인터프리터
    
## 객체
    컴포지트, 데코레이터, 프록시, 퍼사드, 커맨드, 반복자, 옵저버, 상태, 프로토타입, 전략, 추상팩토리, 싱글턴
    비지터, 메멘토, 책임 연쇄, 브리지, 중재자, 플라이웨이트. 빌더


<img width="801" alt="image" src="https://user-images.githubusercontent.com/60346043/175427902-08a38063-d791-4579-a501-0cdf97858316.png">


### 도움이 될만한 사이트
* Design Patterns Catalog: https://refactoring.guru/design-patterns/catalog
* 한빛소프트 [Design pattern] 많이 쓰는 14가지 핵심 GoF 디자인 패턴의 종류: https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8616098823

# 패턴으로 생각하기

## 최대한 단순하게
최대한 단순한 방법(KISS, Keep it Simple)으로 문제를 해결하기<br/>
~"이 문제에 어떻게 패턴을 적용할 수 있을까?"~ -> "어떻게 하면 단순하게 해결할 수 있을까?" 에 초첨을 맞춰야 한다.<br/>
단순하게 **잘** 만들 수 있다면 굳이 패턴을 적용하지 않아도 된다.
<br/>

## 디자인 패턴은 만병 통치약이 아니다
패턴을 사용할때는 해당 패턴이 우리가 설계한 디자인에 미칠 영향과 결과를 주의 깊게 생각해 봐야한다.

## 패턴이 필요할 때
디자인상의 문제에 적합하다는 확인이 든다면 패턴을 도입 해야한다.<br/>
간단한 해결책으로 문제가 해결되는 데도 시스템의 어떤 부분이 변경될 거라고 예측되는 상황에는 디자인 패턴을 적용해야한다.<br/>
디자인에서 변경될 수 있는 부분이 있다면 패턴을 적용할 여지가 있다.<br/>
하지만 가능성이 그리 높지 않은 가상적인 변경에 대비해서 패턴을 적용하는 일은 바람직하지 않다.<br/>
패턴 도입을 디자인 단계에서만 고려해야하는 것은 아니다. 리팩터링 할때도 패턴 도입을 고려할 수 있다.

## 리팩터링과 패턴
리팩터링의 목적은 행동 변경이 아니라 **구조 개선**에 있다.<br/>
패턴을 적용하면 구조가 더 개선 될 수 있을지 검토해 볼 수 있다.

## 디자인에서 패턴을 제거하는일을 두려워 하지 않기
시스템이 점점 복잡해지면서 처음에 기대했던 유연성이 전혀 발휘되지 못한다면 패턴을 과감하게 제거해버리는게 낫다.<br/>
꼭 필요하지 않은 패턴은 빼자. 패턴보다 간단한 해결책이 더 나을것 같으면 패턴을 제거하자.

## 꼭 필요하지 않은 패턴을 미리 정의할 필요는 없다
괜히 패턴을 추가했다가 시스템만 더 복잡해지고 나중에 그 패턴을 사용하지 않을 수도 있다.

## 패턴을 대하는 마음가짐
디자인 패턴을 사용하면 새로운 클래스와 객체를 추가해야 하는 경우가 많은데 그러다 보면 디자인이 복잡해진다.<br/>
그리고 새로운 계층을 추가해야 할 수도 있는데 이 경우 복잡한 문제와 더불어 효율이 떨어지는 문제가 생길 수도 있다.<br/>
디자인 패턴을 사용하려고 애쓰지 말고 간단한 해결책을 사용하자

## 전문 용어의 위력 되새기기
디자인 패턴을 알고 있으면 서로 더 원활하게 의사소통 할 수 있다.<br/>
토론할 때 뿐만 아니라 아키텍쳐 문서나 코드 주석을 달 때, 클래스와 메소드 이름을 만들때 사용중인 패턴이 분명하게 드러나게 해보자.

## 안티 패턴
안티 패턴은 좋은 해결책 처럼 보이지만 적용하고 나서야 좋지 않은 해결책이었다는 사실이 밝혀진다.<br/>
안티 패턴을 문서로 정리해 두면 다른 사람들이 나쁜 해결책을 구현하기 전에 그 문제점을 미리 파악하는데 도움을 줄 수 있다. <br/>
안티패턴은 패턴과 바찬가지로 개발 안티 패턴, 객체지향 안티 패턴, 조직 안티 패턴 등 다양한 종류가 있다.
