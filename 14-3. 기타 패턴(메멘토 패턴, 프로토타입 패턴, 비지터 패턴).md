# 1. 메멘토 패턴

## 정의
- 메멘토: 기억, 기념품
- 객체 내부의 상태를 외부에 저장해놓고, 저장된 상태를 복원할때 사용하는 패턴

<br>

## 특징
- 객체 상태를 캡슐화해서 외부에 노출

- Originator
  - 저장할 상태를 가지고 있는 객체
  - createMementor: 내부 정보를 Memento로 추상화해서 전달해주는 함수
  - restore: 외부에서 전달받는 Memento 정보를 가지고 상태를 복원하는 함수

- CareTaker
  - Originator의 상태를 가지고 와서 저장하고 있음
  - Originator의 상태를 알고 있는게 아니라 Memento라는 타입으로 가지고 있음

- Memento
  - immutable 객체

![스크린샷 2022-07-05 오전 10 37 03](https://user-images.githubusercontent.com/42891424/177242590-b6b77d2d-af47-4633-abcf-432ec033931e.png)

## 장점 
- 객체 내부의 상태를 외부에 노출하지 않고도 객체 상태의 스냅샷을 만들 수 있음
- 복구 기능을 구현하기 쉬움

## 단점
- 상태를 저장하고 복구하는데 시간이 오래 걸릴 수 있음
- 메멘토를 과도하게 사용하면 메모리 문제가 발생할 수 있음

<br/><br/>

# 2. 프로토타입 패턴
## 정의
- 프로토타입: 원형
- 기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법
- 기존 객체를 응용해서 새로운 인스턴스를 만들 때 유용하게 사용
  - 기존 객체가 생성되는데 리소스가 많이 소모될 경우 복제해서 사용하는것이 유용


## 특징
- 복제 기능을 제공할 클래스들이 Prototype 인터페이스를 구현
- clone은 해당 객체를 복제하는 방법을 구현한 함수
- 클라이언트는 clone이라는 함수를 사용해 객체를 복사

![스크린샷 2022-07-05 오후 12 17 17](https://user-images.githubusercontent.com/42891424/177242802-8f653cd4-07f8-4657-89b8-479af2dd450a.png)


## 장점 
- 복잡한 객체를 만드는 과정을 숨길 수 있음
- 기존 객체를 복제하는 과정이 새 객체를 만드는 것 보다 비용 (시간 또는 메모리)적인면에서 효율적일 수도 있음

## 단점
- 객체의 복사본을 만드는 작업이 복잡할 수 있음 (ex. 순환 참조)

<br/><br/>

# 3. 비지터 패턴
## 정의
- 기존 코드를 건드리지않고 새로운 기능을 추가하는 패턴

## 특징
- 더블 디스패치를 활용할 수 있음
- 디스패치: 어떤 요청이 들어왔을 때, 해당 요청을 처리할 구체적인 클래스/메쏘드를 찾아서 처리를 위임하는 과정
- accept(Visitor)
  - visitor가 추가하고 싶은 로직을 담고 있는 함수
  - 비지터 패턴 적용 시 기존 함수에서 accept 함수가 추가되어야함 
  - 내부적으로 Visitor.visit 함수로 자기자신의 타입을 넘겨줌
- Visitor
  - 오버로딩 적용
  - 요소의 개수만큼 함수가 존재

![스크린샷 2022-07-05 오후 12 18 13](https://user-images.githubusercontent.com/42891424/177242854-a36619b6-0f20-4f8c-bb17-b8071b8d673f.png)


## 코드 예시
// Acceptor
<br/>
![스크린샷 2022-07-05 오후 12 36 59](https://user-images.githubusercontent.com/42891424/177244685-d9e2fc3e-1082-4591-8d95-1fd754c6851d.png)
<br/>
// Concrete Acceptor
<br/>
![스크린샷 2022-07-05 오후 12 37 10](https://user-images.githubusercontent.com/42891424/177244692-038e6de5-3101-4106-a5ab-47137fe9395f.png)
<br/>
// Visitor
<br/>
![스크린샷 2022-07-05 오후 12 39 50](https://user-images.githubusercontent.com/42891424/177245261-e8ffb02d-c716-4b38-bedf-cc080d1f8e35.png)
<br/>
// Concrete Visitor
<br/>
![스크린샷 2022-07-05 오후 12 40 05](https://user-images.githubusercontent.com/42891424/177245020-d7f23979-cfdf-4f78-bf89-073564233b47.png)
<br/>
// Client
<br/>
![스크린샷 2022-07-05 오후 12 40 13](https://user-images.githubusercontent.com/42891424/177245285-180cc2bd-f7b0-4739-a8e4-5ba913b0211a.png)





## 장점
- 기존 코드를 수정하지 않고 비교적 손쉽게 새로운 기능을 추가할 수 있음
- 비지터가 수행하는 기능과 관련된 코드를 한 곳에 모아 둘 수 있음

## 단점
- 구조가 복잡해서 이해가 어려움
- 복합 클래스의 캡슐화가 깨짐
- 복합 구조를 변경하기가 어려워짐
